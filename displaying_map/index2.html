<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Turtlesim Web Control</title>
    <!-- Import the ROSLIB library from a CDN to interact with ROS from the web -->
    <script src="https://cdn.jsdelivr.net/npm/roslib/build/roslib.min.js"></script>
</head>
<body>
    <h1>Control Turtlesim</h1>
    <!-- Buttons for sending movement commands to the turtle -->
    <button onclick="sendCommand('up')">Up</button>
    <button onclick="sendCommand('down')">Down</button>
    <button onclick="sendCommand('left')">Left</button>
    <button onclick="sendCommand('right')">Right</button>
    <!-- Canvas element for drawing the map -->
    <canvas id="turtleCanvas" width="500" height="500" style="border:1px solid #000000;"></canvas>

    <script>
        // Establish a connection to the ROS bridge websocket server
        var ros = new ROSLIB.Ros({
            url : 'ws://localhost:9090'  // URL of the ROS bridge server
        });

        // Event handler for successful connection to the websocket server
        ros.on('connection', function() {
            console.log('Connected to websocket server.');
        });

        // Event handler for connection errors
        ros.on('error', function(error) {
            console.log('Error connecting to websocket server: ', error);
        });

        // Event handler for connection closure
        ros.on('close', function() {
            console.log('Connection to websocket server closed.');
        });

        // Create a ROS topic object for publishing velocity commands to the turtle
        var turtle1_velocity_publisher = new ROSLIB.Topic({
            ros : ros,                       // ROS connection instance
            name : '/turtle1/cmd_vel',       // Topic name
            messageType : 'geometry_msgs/msg/Twist' // Message type for velocity commands
        });

        // Function to send movement commands to the turtle based on button clicks
        function sendCommand(direction) {
            console.log('Sending command: ' + direction); // Log the command being sent
            
            // Create a new Twist message with default values of zero
            var twist = new ROSLIB.Message({
                linear : {
                    x : 0.0,  // Linear velocity in x-direction
                    y : 0.0,  // Linear velocity in y-direction
                    z : 0.0   // Linear velocity in z-direction
                },
                angular : {
                    x : 0.0,  // Angular velocity around x-axis
                    y : 0.0,  // Angular velocity around y-axis
                    z : 0.0   // Angular velocity around z-axis
                }
            });

            // Set the appropriate velocity values based on the direction
            switch(direction) {
                case 'up':
                    twist.linear.x = 2.0; // Move forward
                    break;
                case 'down':
                    twist.linear.x = -2.0; // Move backward
                    break;
                case 'left':
                    twist.angular.z = 2.0; // Rotate counterclockwise
                    break;
                case 'right':
                    twist.angular.z = -2.0; // Rotate clockwise
                    break;
            }

            // Publish the Twist message to the /turtle1/cmd_vel topic
            turtle1_velocity_publisher.publish(twist);
        }

        // Create a ROS topic object for subscribing to the map
        var mapListener = new ROSLIB.Topic({
            ros : ros,
            name : '/map',  // Make sure this is the correct topic name for your map
            messageType : 'nav_msgs/msg/OccupancyGrid'  // Message type for map data
        });

        // Subscribe to the map and update the canvas whenever a new map is received
        mapListener.subscribe(function(message) {
            console.log('Received map: ', message); // Log the received map
            drawMap(message); // Draw the map on the canvas
        });

        // Get the canvas element and its context for drawing
        var canvas = document.getElementById('turtleCanvas');
        var ctx = canvas.getContext('2d');

        // Function to draw the map on the canvas
        function drawMap(map) {
            var width = map.info.width;
            var height = map.info.height;
            var data = map.data;

            // Create imageData object to store map data
            var imageData = ctx.createImageData(width, height);

            for (var y = 0; y < height; y++) {
                for (var x = 0; x < width; x++) {
                    var index = x + y * width;
                    var value = data[index];
                    
                    var gray; // Declare the gray variable
                    
                    // Determine the color based on the value
                    if (value === -1) {
                        gray = 127; // Gray for unknown cells
                    } else if (value > 50) {
                        gray = 0; // Black for occupied cells
                    } else {
                        gray = 255; // White for free cells
                    }

                    // Set the pixel color in the image data object
                    var pixelIndex = (x + (height - y - 1) * width) * 4;
                    imageData.data[pixelIndex] = gray;
                    imageData.data[pixelIndex + 1] = gray;
                    imageData.data[pixelIndex + 2] = gray;
                    imageData.data[pixelIndex + 3] = 255; // Fully opaque
                }
            }

            // Clear the entire canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Create a temporary canvas to draw the imageData and scale it
            var tempCanvas = document.createElement('canvas');
            var tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = width;
            tempCanvas.height = height;
            tempCtx.putImageData(imageData, 0, 0);

            // Calculate the scaling factor to fit the map into the canvas
            var scaleX = canvas.width / width;
            var scaleY = canvas.height / height;

            // Draw the scaled image onto the main canvas
            ctx.drawImage(tempCanvas, 0, 0, width, height, 0, 0, canvas.width, canvas.height);
        }
    </script>
</body>
</html>


